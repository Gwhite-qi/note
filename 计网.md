## IP

### 小林知识点梳理

#### IPv4 地址分类

##### ABCDE类

##### 单播、广播、组播

#### CIDR

##### 网络号和主机号区分 

- 方式1：`a.b.c.d/x`，其中 `/x` 表示前 x 位属于**网络号**
- 方式2：子网掩码

##### 子网划分

将主机地址分为两个部分：子网网络地址和子网主机地址

```
举例：假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 对其进行子网划分。C 类地址中前 24 位是网络号，最后 8 位是主机号，根据子网掩码可知从 8 位主机号中借用 2 位作为子网号。
那么子网有4个，子网的两位的表示分别为00、01、10、11
```

#### **127.0.0.1 作为环回地址**

不会流向网络：给环回地址发消息相当于是给本机发消息。会在数据链路层次下面通过一个**‘假网卡’**，然后由本机读取。

IP分片只会在源主机和目标主机分片和重组，路由器不会重组的。在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 **TCP 引入了 `MSS` 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 `MTU` 的数据报文**。

因为如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。

#### IPv6

##### 128位表示

以每 16 位作为一组，每组用冒号 「:」 隔开。出现连续的 0 时还可以将这些 0 省略，并用两个冒号 「::」隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。

##### 优点

1. 可以自动配置IP地址,便捷即插即用
2. 首部固定40字节
3. 安全性高

##### 有单播和组播，但是没有广播

##### IPv6 单播地址类型

- 在同一链路单播通信，不经过路由器，可以使用**链路本地单播地址**，IPv4 没有此类型
- 在内网里单播通信，可以使用**唯一本地地址**，相当于 IPv4 的私有 IP
- 在互联网通信，可以使用**全局单播地址**，相当于 IPv4 的公有 IP

#### ICMP

##### 分为查询报文（ping的实现）和差错报告（traceroute的实现）

ping：可以向对端主机发送**回送请求**的消息（`ICMP Echo Request Message`，类型 `8`），也可以接收对端主机发回来的**回送应答**消息（`ICMP Echo Reply Message`，类型 `0`）。ping 是**应用层**命令，ping应用的底层，用的是网络层的**ICMP协议**。

traceroute：通过设置TTL（IP数据包中设定的最大路由跳数），**来追踪去往目的地时沿途经过的路由器**；故意设置不分片，从而确**定路径的 MTU**。

##### 封装在IP数据包中，在网络层

虽然ICMP协议和IP协议**都属于网络层协议**，但其实**ICMP也是利用了IP协议进行消息的传输**

#### 不懂

##### IPv6 地址的结构

##### 127.0.0.1 和 localhost 以及 0.0.0.0 的区别



## TCP

### 小林知识点梳理

#### TCP 四元组

- TCP 四元组可以唯一的确定一个连接（源地址、源端口、目的地址、目的端口），有一个不同就是不同的连接

- 每个 TCP 连接都是一个文件，socket

#### 关于端口

##### TCP 和 UDP 可以使用同一个端口

传输层的「端口号」的作用，是为了区分**同一个主机上不同应用程序**的数据包；TCP 和 UDP，在内核中是两个完全独立的软件模块。

##### 多TCP使用同一个端口



#### 三次握手

##### 会画图

##### 第三次握手是可以携带数据的，前两次握手是不可以携带数据的

##### 为什么是三次握手

###### 阻止重复历史连接的初始化

因为网络阻塞导致客户端重复发送了两次，而旧的syn先到达，服务器会发挥syn+ack响应。在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致**服务端可能建立一个历史连接**，造成资源浪费。

如果是三次连接的话，客户端会看到不符合预期的ack会回复RST，这样**在服务器在未建立连接的时候就终止了本次握手**，而不是连接之后再放弃本次连接。

###### 确保双方的初始序列号能被可靠的同步

###### 避免建立多个冗余的无效链接，造成资源浪费

##### 随机初始化序列号

初始化序列号使用ISN随机生成算法，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号；

如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题；

客户端和服务端的初始化序列号都是随机生成，能很大程度上避免历史报文被下一个相同四元组的连接接收，然后又引入**时间戳**的机制，从而完全避免了历史报文被接收的问题。

##### TCP 协议在建立连接的时候通常要协商双方的 MSS 值，避免IP分片

##### 丢失问题

###### 第一次握手丢失

触发客户端超时重传，重传的 SYN 报文的**序列号都是一样的**；

重发次数由tcp_syn_retries确定，每次超时的时间是上一次的 2 倍；

如果最终还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接；

###### 第二次握手丢失

**客户端**就会触发**超时重传**机制，重传 SYN 报文（客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文丢失了），最大重传次数由 `tcp_syn_retries`内核参数决定，超过次数收不到第二次握手，客户端断开连接；

**服务端**这边会触发**超时重传**机制，重传 SYN-ACK 报文（如果第二次握手丢失了，服务端就收不到第三次握手），重传次数由内核参数`tcp_synack_retries`参数决定，超过次数收不到第三次握手，服务端断开连接；

###### 第三次握手丢失

**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**，所以是说客户端不会重发，要靠服务端重发syn+ack报文；

重传次数由内核参数`tcp_synack_retries`参数决定，超过次数收不到第三次握手，服务端断开连接；

##### syn攻击

###### TCP 半连接和全连接队列

假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，但是在服务端发送第二次握手后，**无法得到未知 IP 主机的 `ACK` 应答**，久而久之就会**占满服务端的半连接队列**；

**当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

###### 解决办法

- 当网卡接收数据包的速度大于内核处理的速度时，会有一队列保存这些数据包，增大该队列参数；

- 增大半连接队列；

- 开启 tcp_syncookies
  - 当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 **`cookie` 值**；将 **cookie 值放到第二次握手报文**的「序列号」里，然后服务端回第二次握手给客户端；服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果**合法**，将该连接对象放入到**「 Accept 队列」**；最后应用程序通过调用 `accpet()` 接口，从「 Accept 队列」取出的连接
  - cookies也需要存储。。。
- 减少 SYN+ACK 重传次数

#### 四次挥手

关闭连接的方式通常有两种，分别是 **RST 报文关闭和 FIN 报文关闭**。

##### 会画图

##### 为啥4次

###### 4次的原因

需要双方都关闭连接；

被关闭端需要先把剩余未发送的数据发送完，才能发送FIN断开连接；

两次一来一去就是4次握手；

###### 可以合并为3次

没有数据再发送＋「 TCP延迟发送」

##### 丢失问题

###### 第一次握手丢失

触发 主动断开端 超时重传，由参数`tcp_orphan_retries`控制，超过参数后如果还是没能收到第二次挥手，那么直接进入到 `close` 状态；

###### 第二次握手丢失

因为ACK报文不会超时重传，所以还是 主动断开端 第一次挥手重传；

**ps**：对于**close 函数**关闭的连接，`FIN_WAIT2` 状态不可以持续太久， `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒，如果在 60 秒后还没有收到 FIN 报文，主动关闭方的连接就会**直接关闭**；而**shutdown函数**关闭的连接，没有限制，会在`FIN_WAIT2`状态死等；

###### 第三次握手丢失

触发 被动断开端 超时重传，由参数`tcp_orphan_retries`控制，超过参数后如果还是没能收到第四次挥手，那么直接进入到 `close` 状态；

###### 第四次握手丢失

触发 被动断开端 超时重传，由参数`tcp_orphan_retries`控制，超过参数后如果还是没能收到第四次挥手，那么直接进入到 `close` 状态；

此时在等待第四次挥手时，主动断开方处于`TIME_WAIT`状态，那么每次收到第三次挥手，TIME_WAIT都会重置，直到过期，断开连接；

##### TIME_WAIT

###### 2MSL时长

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，或者说是自然消亡的时间；

 **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。

###### 作用

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收（延迟的网络包没有消亡，在下一个相同连接中到达并且正好在接收窗口范围内）

  `2MSL` 时长，这个时间**足以让两个方向上的数据包都被丢弃**，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的

- 保证「被动关闭连接」的一方，能被正确的关闭

  没有 TIME_WAIT 状态的话，在发送完第4次挥手时关闭，这个时候如果第四次挥手丢失，主动关闭方在收到重发的FIN时，会发送RST给被动关闭方；

###### ⭐TIME_WAIT状态过多

会占用内存资源和端口资源

###### TIME_WAIT状态优化

1. tcp_tw_reuse

- 功能只能用于连接发起方，在connect()的时候，内核会随机找一个 **time_wait 状态超过 1 秒**的连接给新的连接复用

- 前提是要打开对 TCP 时间戳的支持tcp_timestamp,

  - tcp_timestamp可以便于精确计算 RTT 。

  - ⭐tcp_timestamp还可以为**PAWS机制**提供信息依据，保证安全性

    - 防止序列号回绕：PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，**如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包**

    - 但是呢，时间戳也是有可能回绕的，Linux 在 PAWS 检查做了一个特殊处理，如果一个 TCP 连接连续 24 天不收发数据则在接收第一个包时基于时间戳的 PAWS 会失效。其他的可以对时间戳的大小位数进行扩大，或者选择一个不会回绕的方式等

    - tcp_tw_recycle 在使用了 NAT 的网络下是不安全的！

      对于服务器来说，如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」，这个时候呢，**per-host 是对「对端 IP 做 PAWS 检查」**，而非对「IP + 端口」四元组做 PAWS 检查。

- 也会存在问题（默认不开启）：

  - RST的时间戳就算过期，**只要 RST 报文的序列号在对方的接收窗口内**，也有可能被接收，这样有可能是新连接收到旧连接的RST；
  - 如果旧连接的第四次挥手丢失，被动断开方会重发第三次挥手，如果此时主动断开方发送syn建立连接，被动断开方发送challenge ack，然后本次新连接会断开。


2. tcp_max_tw_buckets

   当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置

3. 通过设置 socket 选项，来设置调用 close 关闭连接时，直接发送RST给对方，跳过四次握手

###### 出现过多该状态的原因

1. http没使用长连接

    HTTP Keep-Alive没有被开启；根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由**服务端主动关闭连接**

2. http长连接超时

   有**大量的客户端**建立完 TCP 连接后，很长一段时间**没有发送数据**，HTTP 长连接超时，导致服务端主动关闭连接

3. HTTP 长连接的请求数量达到上限

   一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接

##### ⭐服务器出现大量 CLOSE_WAIT 状态的原因

通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close



##### ⭐close和shutdown

`close` 函数意味着完全断开连接，完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」；`shutdown` 函数，**它可以控制只关闭一个方向的连接**：可以单独关闭读方向、写方向，或者同时关闭读写方向。

如果客户端是用 **close 函数**来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的**数据**，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 **RST 报文**给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。

而如果是shutdown函数关闭发送方向，服务端发送数据还是可以正常回应的，直到正常关闭。

#### 连接编程相关

##### 会画图

##### 函数作用

###### socket()

​	初始化socket文件描述符

###### bind() 

​	将产生的socket和当前连接的IP地址和端口 绑定好

###### listen() 

​	监听连接请求，产生半连接和全连接队列；

​	如果没有listen，当客户端向服务端发起连接时，服务器端无法生成半连接和连接队列，会回复一个RST报文。

​	没有listen的情况下可以建立TCP连接：1、客户端可以与自己形成TCP自连接; 2、两个客户端同时发出连接请求形成TCP连接；原理是**在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入一个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接**。

###### connect() 

​	客户端发出连接请求，在得到syn+ack回应后函数返回，即客户端 connect 成功返回是在第二次握手

###### accept() 

​	等待客户端连接，在建立全连接后返回，即服务端 accept 成功返回是在三次握手成功之后；

​	注意accept不会影响连接的建立，它的作用就是在全连接队列中选取一个建立完成的socket返回。

###### read()

###### write()

###### close() 

​	客户端发送FIN报文给到服务端，服务端会添加EOF到接收缓冲区，放在其他已接收的数据之后并进入CLOSE_WAIT；服务端最终读到EOF后，也调用close()发送FIN，同时进入LAST_ACK状态；

#### 重传机制、流量控制及拥塞控制

##### 重传机制

###### 超时重传

`RTT` 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是包的往返时间，`RTO`指的是设置的**超时重传时间 **

###### 快速重传

发送端同时发送了seq1-seq5，当发送端收到了连续三个 Ack = 2 的确认，知道了 对应的Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。如果客户端收到了seq2，就会返回一个ack=6的报文。

问题：重传的时候，是重传一个，还是重传所有的

###### SACK

在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

###### Duplicate SACK

 又称 `D-SACK`，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**

同SACK区分的技巧是 如果sack大于ack，说明是有丢失数据没传；如果sack小于ack，说明收到了重复的数据；

##### 流量控制

###### 滑动窗口

- 窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**；

- **累计确认**或**累计应答**：如果有ack丢失了，可以根据下一个ack确认对方是否收到了数据；

- **发送窗口**：
  - 根据接收方的窗口确认，一般不大于接收方的窗口大小；
  - 发送缓存包括 发送窗口 和 可发送但不在接受范围内的数据
  - 窗口包括 **已发送但未收到ack的部分 和 可用窗口（未发送但是在接收方接收范围内）**两部分
  - 当有新的ack收到则滑动窗口；
- 接收窗口
  -  接收缓存包括 已接收等待读取的数据 和 未接收但可被接收的数据
  - 当应用程序读取接收缓存中的数据时，接收窗口增大；当接收新的数据时，接收窗口减小；

###### 流量控制

- TCP 提供一种机制可以让**「发送方」根据「接收方」的实际接收能力控制发送的数据量**，这就是所谓的流量控制；

- 操作系统的缓冲区，会**被操作系统调整**，就会影响接收窗口的大小。如果窗口调整没有来得及告知客户端，就会导致客户端发送的数据大小大于接收窗口大小，从而出现丢包的现象。 所以TCP 规定是**不允许同时减少缓存又收缩窗口**的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况；
- 窗口关闭：
  - 接收方向发送方通告窗口大小时，是通过 `ACK` 报文来通告；
  - 如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是**窗口关闭**；而通告窗口的ack报文很可能会丢失从未出现双方均没有下一步动作的**死锁状态**；
  - 解决窗口关闭的问题：只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。
- 糊涂窗口综合症
  - 如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是**糊涂窗口综合症**；就是说接收窗口很小，但是发送方在头部开销很大的情况下就发送几个字节，很浪费资源；
  - 解决方法
    - 让接收方不通告小窗口给发送方: 当「窗口大小」**过小**，就会向发送方通告窗口为 **0**
    - 发送方避免发送小数据:  **Nagle 算法**（条件一：要等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS`；条件二：收到之前发送数据的 `ack` 回包；）

##### 拥塞控制

- 避免「发送方」的数据填满整个网络，拥塞控制下，发送窗口＝min(接收窗口， 拥塞窗口)

- **拥塞窗口 cwnd**在网络状况好的情况下增大，出现拥塞就会减小；如果网络发生了超时重传，就会认为网络出现了拥塞

- 拥塞控制有几种算法：

  ###### 慢启动

  设定慢启动门限 `ssthresh`，cwnd呈2^n指数增长，直到ssthresh，开始拥塞避免算法

  ###### 拥塞避免

  每当收到一个 ACK 时，cwnd 增加 **1/cwnd**。当出现丢包时，拥塞发生算法。

  ###### 拥塞发生

  针对超时重传和快速重传有不同的应对机制：

  - 超时重传：`ssthresh` 设为 `cwnd/2`，`cwnd` 重置为初始化值（比如从1开始），然后进入**慢启动**算法。
  - 快速重传：`cwnd = cwnd/2` ，`ssthresh = cwnd`， 然后进入快速恢复算法

  ###### 快速恢复

  - `cwnd = ssthresh + 3 `(表示在快速重传发生时已经收到了3个连续的ack包)
  - 然后重传丢失的数据包，每收到一个ack将`cwnd＋1`，直到将丢失的数据包全部重传完毕（这个时候cwnd加大的原因是因为TCP认为目前的首要任务是解决数据包丢失的问题）
  - 然后在收到新数据的ack时，`cwnd = ssthresh`，再次进入拥塞避免状态。

#### 	TCP优化

##### 连接建立的三次握手优化

###### 客户端优化

减少syn重传次数

###### 服务端优化

减少syn+ack重传次数；增大syn半连接队列大小（这个必须和增大全连接队列长度一起）；开启 syncookies 功能；增大accpet长度

###### ※TCP Fast Open

三次握手是在第三次握手的时候才能发送数据；

开启FastOpen之后，在首次建立连接时，客户端会申请cookie，之后在非首次建立连接时，会在syn中加上cookie和数据，如果服务端校验cookie有效则在之后的syn+ack中确认数据，否则cookie无效就只确认syn。那么就可以在初次握手时就传递数据，减少了一个RTT的时延。

##### 连接断开的四次握手优化

- 减少FIN报文重传次数（主动断开方和被动断开方）
- 调用close关闭时，防止孤儿连接过多，导致系统资源长时间被占用，减少 `tcp_max_orphans` 
- 调用close关闭时，调整FIN_WAIT2的状态时长（因为shutdown关闭的可能还要接收或者发送数据。所以可以一直处于FIN_WAIT2状态）
- 调整TIME_WAIT状态的上限（**超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭**）
- 复用TIME_WAIT状态的连接 **tcp_tw_reuse**

##### ⭐数据传输时的性能提升

扩大窗口大小；调整发送缓冲区和接收缓冲区范围（**发送缓冲区是默认自行调节的**，接收缓冲区需要设置自动调节）；调整TCP内存范围；

#### TCP字节流

完整的消息可能会被操作系统分组成多个的 TCP 报文，**不能认为一个用户消息对应一个 TCP 报文**；

###### TCP 粘包问题

两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 **TCP 粘包问题**；

解决方法有：固定消息长度、使用特殊字符作为边界（那么报文中的特殊字符要使用转义）、自定义消息结构（比如自行添加结构体说明长度等）

- 例如：HTTP 协议通过设置回车符、换行符作为 **HTTP header 的边界**，通过 Content-Length 字段作为 **HTTP body 的边界**，这两个方式都是为了解决“粘包”的问题

#### 故障/异常

##### 保活机制

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个**探测报文**，该探测报文包含的数据非常少。

如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序；得到回应，会清空时间重新计时，直到达到下次保活机制启动门槛。

##### 运行中客户端故障

###### 客户端一直宕机

- 如果服务端发送数据并超时重传没有响应，认为当前的 TCP 连接已经死亡；

- 如果服务器没有发送数据，开启保活机制，会在探测后，释放该连接（没开启保活的话就一直处于established）；

###### 客户端宕机并重启

- 如果客户端重启后响应来自服务端的探测报文，服务端收到后发现如果没有该连接的有效信息，会产生RST报文。
- 如果客户端重启后双方一直没有通信，如果服务器开启保活机制，发现连接断开则会释放该连接（没开启保活的话就一直处于established）。

- 如果重启后向服务器发送syn报文，而此时服务器并不知道客户端宕机的事情：
  - 如果该syn请求的连接和原连接不同（四元组不同），那么正常三次握手建立连接。历史连接的处理参考上面两点。
  - 如果该syn请求的连接和原连接相同，也就是处于 Established 状态的服务端收到了这个 SYN 报文，此时会回复一个携带了正确序列号和确认号的 ACK 报文（称之为 **Challenge ACK**），客户端收到后发现确认号（ack num）并不是自己期望收到的，于是就会**回 RST 报文**，服务端收到后，就会释放掉该连接。

##### 进程崩溃

内核会完成与对方的四次挥手，结束连接。

##### 不合时宜的SYN

###### 客户端宕机重启重新SYN申请建立连接

（在 ‘运行中客户端故障’ 中已经提到）

######  TIME_WAIT 状态收到 SYN 

- 关键是要看 SYN 的「序列号和时间戳」是否**合法**

  客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要**大**，**并且** SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要**大**； 否则就是非法的。

  合法：重用该四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程

  不合法：再回复一个第四次挥手的 ACK 报文，对方收到后，发现并不是自己期望收到确认号，就回 RST 报文给自己



##### 不合时宜的FIN

###### 四次挥手中收到乱序的 FIN 包会如何处理

在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文（前面的数据延迟了），那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。

等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。

##### 客户端断网

###### 断网后有数据传输

- 如果服务端发送了数据报文，那么在服务端**重传次数没有达到最大值**之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。
- 如果服务端发送了数据报文，在客户端插回网线之前，服务端**重传次数达到了最大值**时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，服务端回 RST 报文，客户端收到后就会断开 TCP 连接。

###### 断网后无数据传输

- 都没开启keepalive，就会一直处于established状态
- 开启keepalive，如果赶在探测期间插入网线，还能继续通信，不然就会断开连接。

#### 缺点

##### 升级 TCP 的工作很困难

因为处于内核中，升级TCP需要升级内核，而内核升级涉及到底层软件和运行库更新等，导致内核升级保守缓慢。

##### 连接延迟

虽然有fast open但是不够普及；

而且TCP在内核和TLS终究的分离的，握手理论是分开的；并且TCP头部无法被加密，还是有安全性问题；

##### 队头阻塞

字节流协议，还要保证收到的数据是有序完整的，才能被读取，不然就在接收队列阻塞；HTTP/2的队头阻塞也是因此而起。

##### 迁移问题

当移动设备的网络从 4G 切换到 WIFI 时，意味着 **IP 地址**变化了，即TCP连接的四元组改变，那么就必须要断开连接，然后**重新建立** TCP 连接。

#### 用了TCP一定不会丢包吗

发送链路很长，不可避免丢包（比如连接建立丢包、流量控制时丢包、在网卡处丢包、在路由器交换机处丢包、接收时丢包等）；

但是TCP会有重传机制，所以不用过于关注丢包问题；

TCP只保证传输层之间的可靠性，至于应用层的安全保证，还需要另作处理；

## UDP+QUIC

### 可靠传输

通过数据包头部封装实现，http →QUIC frame → QUIC packet → UDP

#### QUIC frame

每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。

重传数据包的 QUIC Packet N+M 与丢失数据包的 Packet N 编号并不一致，所以引入 Frame Header 这一层，通过**比对 Stream ID + Offset** 字段信息实现数据的**有序性**。

比如 Stream 类型的 Frame 格式中有

- Stream ID ：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；
- Offset ：类似于 TCP 协议中的 Seq 序号，**保证数据的顺序性和可靠性**；
- Length ：指明了 Frame 数据的长度；



#### QUIC packet

然后是QUIC packet，一个 Packet 报文中可以存放多个 QUIC Frame。

头部的**packet_number**有点类似于TCP的序列号，但是是严格递增的（即使是丢失重传的数据也会按照发送顺序重新编号），接收端支持乱序确认，这样即使有包丢失等待重传，也可以将窗口滑动，解决队列阻塞的问题。

并且相比TCP重传报文的时候序号相同，更加精确地计算 RTT，避免歧义。

### 处理队头阻塞

QUIC 给每一个 Stream 都分配了一个**独立的滑动窗口**，这样使得**一个连接上的多个 Stream 之间没有依赖关系**，都是相互独立的，各自控制的滑动窗口。及时其中一个stream丢包了，也不会影响其他stream的传输。

### 流量控制

QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：

- **Stream 级别的流量控制**：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。

  每个stream已收到的顺序的数据超过**最大接收窗口的一半**后，最大接收窗口向右移动，接收窗口的右边界也向右扩展，同时给对端发送「窗口更新帧」，当发送方收到接收方的窗口更新帧后，发送窗口的右边界也会往右扩展，以此达到**窗口滑动**的效果。

- **Connection 流量控制**：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。

### 拥塞控制

QUIC 协议相当于将 TCP 的拥塞控制算法照搬过来了。

因为 QUIC 处于应用层，所以就**可以针对不同的应用设置不同的拥塞控制算法**，这样灵活性就很高

### 快速建立

QUIC 内部**包含了 TLS**，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 **1 个 RTT** 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 **0-RTT** 的效果。

### 连接迁移

QUIC 协议通过**连接 ID** 来标记通信的两个端点。即使IP 地址变化，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，达到了**连接迁移**的功能。

## HTTP

HTTP 是一个在计算机世界里专门在「**两点**」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

### 报文分类

报文由三个部分组成，即开始行、首部行和实体主体。

首部行的格式：首部字段+值

#### 请求报文

从客户向服务器发送请求报文；

##### 请求行

在请求报文中，开始行就是**请求行**，包括方法、URL和版本。

- **方法**

  - 指对所请求的对象进行的操作，请求报文的类型是由它所采用的方法决定的。

  - 方法包括GET、POST、DELETE等方法

    ###### GET（ RFC 规范定义的语义）

    GET 的语义是从服务器获取指定的资源，**安全且幂等**，可被缓存的；

    ###### POST（ RFC 规范定义的语义）

    POST的语义是根据请求负荷（报文body）对指定的资源做出处理，**不安全不幂等**；

- **URL**指请求资源的URL

- **版本**指的是HTTP的版本





 

#### 响应报文

从服务器到客户的回答；

在请求报文中，开始行就是**状态行**，包括版本、状态码、解释状态码的短语。

- **版本**

  指的是HTTP的版本****

- **状态码**

  - 常见状态码 https://www.xiaolincoding.com/network/2_http/http_interview.html#http-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B

#### 首部字段

##### 常见首部字段

https://www.xiaolincoding.com/network/2_http/http_interview.html#http-%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B

### HTTP缓存

#### 强制缓存

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于**浏览器**这边。

如果过期，重新请求服务器。

#### 协商缓存

协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在**未能命中强制缓存**的时候，才能发起带有协商缓存字段的请求。

通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存（协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存）。比如请求响应码为304，表示重定向到本地缓存。

*简单来说，在未能命中强制缓存的时候，发起申请问问服务器是不是之前缓存的还能用，如果能用返回304报文，不然返回200响应请求。*

### HTTP演变

#### HTTP/1.0→HTTP/1.1： 

长连接和管道传输

但是管道不默认开启，并且管道**没有解决http顺序响应的队头阻塞**

#### HTTP/1.1→HTTPS：

加入了 SSL/TLS 安全协议，保证安全性

#### HTTP2：

##### 基于 HTTPS ，安全性有保证

##### 和HTTP/1.1对比：

###### 头部压缩 HPACK算法

###### 二进制格式

###### 并发传输

但是存在TCP接收的队头阻塞i

###### 服务器可以推送

可以双向建立连接

#### HTTP2→HTTP3

##### UDP+QUIC

QPACK算法等



### HTTP1.1特性

#### 优缺点

##### 优点：

简单、灵活和易于扩展、应用广泛和跨平台

##### 缺点：

###### 无状态双刃剑

（ **Cookie** 技术来解决）

###### 明文传输

###### 不安全

- 明文，窃听风险（号没了）
- 不验证身份，冒充风险（钱没了）
- 不验证完整性，篡改风险（眼没了）

#### 性能

性能一般般

##### 默认长连接

##### 管道网络传输

<u>（不是默认开启，而且浏览器基本都没有支持）</u>

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

意思就是可以**连续发送**，即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

服务器必须按照接收请求的**顺序**发送对这些管道化请求的**响应**，所以，HTTP/1.1 管道**解决了请求的队头阻塞**，但是没有解决**响应的队头阻塞**。

##### 队头阻塞

如果不用管道，那就是请求阻塞，收不到回应，下一条请求就发不出去。

#### 如何优化

##### 尽量避免发送http请求

缓存

##### 减少http请求次数

###### 减少重定向请求次数

重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数；

代理服务器提前得知重定向的规则，不用询问，直接重定向请求；

###### 合并请求

以一个大资源的请求替换多个小资源的请求

###### 延迟发送请求

啥时候需要啥时候再请求

##### 减少 HTTP 响应的数据大小

对响应的资源进行**压缩**：文本文件、程序可执行文件、程序源代码等使用无损压缩，对于视频图片音频可以使用有损压缩。



不管怎么优化 HTTP/1.1 协议都是有限的



### HTTPS特性

#### 解决的问题

HTTPS 解决 HTTP **不安全**的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。因此在 TCP 三次握手之后，还需进行 **SSL/TLS 的握手**过程，才可进入加密报文传输。

- **信息加密**：解决窃听风险
- **校验机制**：解决篡改风险
- **身份证书**：解决冒充风险

##### 信息加密：

对称加密和非对称加密一同的**混合加密**，解决窃听风险

###### 通信前使用非对称加密来交换会话密钥

**非对称加密**：

加密和解密的密钥不相同，包括公钥和私钥，公开密钥和私有密钥是配对的一对密钥。这两个密钥可以**双向加解密**的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。

流程的不同，意味着目的也不相同：

- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

**HTTPS中的流程**：

公钥加密，私钥解密。

发送方收到接收方的公钥，将会话密钥通过公钥加密发送给接收方，然后接收方用自己的私钥解密得到会话密钥。之后双边便通过该会话密钥加密和解密信息。

###### 使用对称加密的会话密钥通信

##### 校验机制

通过摘要算法＋数字签名的形式，解决篡改风险。

1、首先，**防止内容被篡改**。发送方通过对传输内容计算一个指纹（哈希值）并一起传送，接收方接收时先根据内容计算哈希值，如果和收到的哈希值一致，就认为内容没有被改过。

2、然后，还要保证 **内容＋ 哈希值** 没有一同被别人**改**过。使用***私钥加密，公钥解密***的方式，用私钥对**内容的哈希值加密**作为数字签名，如果接收方的哈希值可以用公钥解密，说明哈希值没有被篡改过。

##### 身份证书

通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。万一最开始收到的服务器公钥是假的，会有一系列问题和风险出现。

**流程**：

1、服务器将自己的公钥注册到CA（数字证书认证机构）

2、CA 签发证书：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打包，然后对这些信息进行 Hash 计算，得到一个 **Hash 值**；
- 然后 CA 会使用自己的**私钥将该 Hash 值加密**，生成 Certificate Signature，也就是 CA 对证书做了**数字签名**；
- 最后将 Certificate Signature 添加在文件证书上，形成**数字证书**；

3、然后客户端校验服务端的数字证书：

- 首先客户端会使用同样的 Hash 算法获取该证书的 **Hash 值** H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 **CA 的公钥解密** Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后**比较** H1 和 H2，如果**值相同**，则为**可信赖**的证书，否则则认为证书不可信。

#### ⭐TLS

##### TLS握手协议

首先，TLS握手之前需要完成TCP连接。

使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 和 ECDHE 算法

###### RSA算法

**握手过程**：

1、ClientHello

​	客户端发送加密通信请求：随机数1、TLS版本、支持的加密算法

2、SeverHello

​	服务器响应：随机数2、发送数字证书、确定TLS版本和加密算法等

3、客户端回应

​	生成随机数3（三个数字通过协商的解密算法生成会话密钥）

4、服务端回应

​	之后使用会话密钥通信

**缺点**：不支持**前向保密**，就是说如果服务器公钥泄露了就完蛋了

###### ECDHE 算法

ECDHE 算法具有前向安全，所以被广泛使用。「支持」前向保密。

**握手过程：**https://www.xiaolincoding.com/network/2_http/https_ecdhe.html#ecdhe-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B

##### TLS记录协议

负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议

##### 几次握手

SSL/TLS 1.2 需要 4 握手，需要 2 个 RTT 的时延；

SSL/TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也就是只需要 3 次握手；

#### 如何优化

https://www.xiaolincoding.com/network/2_http/https_optimize.html#%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97

### HTTP/2

#### 兼容 HTTP/1.1

- 没有在 URL 里引入新的协议名，仍然用「http://」表示明文协议，用「https://」表示加密协议；

- 只在应用层做了改变，把 HTTP 分解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变，在「语法」层面做了很多改造，基本改变了 HTTP 报文的传输格式。

#### ⭐头部压缩

HTTP/1.1 协议可以对body部分做压缩，但是头部压缩没有对应的优化手段。

##### **HPACK** 算法

#### 二进制帧

将 HTTP/1 的文本格式改成二进制格式传输数据，提高传输效率；

具体来说，将响应报文分为数据帧和头部帧两部分来传输，二进制帧头部会表明帧的长度、类型（数据帧/控制帧）、流标识符，二进制帧的数据部分是通过HPACK算法压缩的http头和包体。

数据帧又分为HTTP包体、HTTP头部等多个类型，控制帧包括stream流终止、流量控制等类型。

#### 并发传输

多个 Stream 复用一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，一条HTTP 的请求/响应消息可以由多个 Frame 构成， 一个 Frame 中存放http报文的头部或包体等；

不同 Stream 的帧是可以**乱序发送**的（因此可以并发不同的 Stream ），接收端可以通过 Stream ID 有序组装成 HTTP 消息，所以**同一 Stream 内部的帧必须是严格有序的**。

但是TCP层面在接收的时候还是存在队头阻塞。

#### 服务器主动推送资源

客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。

### HTTP/3

HTTP/3 将传输协议替换成了 UDP，并基于 UDP 协议在「应用层」实现了 **QUIC 协议**。头部压缩改用QPACK算法

#### 头部压缩

QPACK

#### QUIC

- 无队头阻塞

  QUIC 连接上的多个 **Stream 之间并没有依赖**，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响；

- 更快的连接建立

  HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 **QUIC 内部包含了 TLS**，仅需 **1 个 RTT** 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 **0-RTT** 的效果。

- 连接迁移

  QUIC 协议通过**连接 ID** 来标记通信的两个端点。即使IP 地址变化，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，达到了**连接迁移**的功能。



### HTTPS 中 TLS 和 TCP 能同时握手

https://www.xiaolincoding.com/network/3_tcp/tcp_tls.html

### TCP Keepalive 和 HTTP Keep-Alive

前者是保活机制，为了探测连接是否还存在；

后者是为了实现长连接，避免多次短连接造成的麻烦，可以使用**同一个 TCP 连接**来发送和接收**多个 HTTP** 请求/应答，避免了连接建立和释放的开销；

## 各个相关协议是通过什么包装的 应用在哪个层